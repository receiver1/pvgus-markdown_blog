---
name: Краткий обзор VMP 3.x — Часть 2. Мутация кода
description: Я использовал демо-версию VMProtect 3.5 для своих тестов и вот что получилось...
date: 10.12.2025
---

Привет

Вот мое краткое исследование механизма мутации VMP.

VMProtect - это хорошо известная защита с множеством функций, основной из которых является механизм виртуализации. Это очень хороший и оптимизированный механизм, даже если элитные крякеры говорят, что он не на уровне Themida. Взлом его механизма виртуализации занимает много времени, поэтому я не особо сосредоточен на этом прямо сейчас. Но есть другая функция VMP, которая интересна для меня - это механизм мутации кода. По сути, это способ изменить форму кода, не меняя его назначения. Поскольку есть несколько способов сделать одно и то же, VMP мутирует код так, что он остается тем же, но с другой сигнатурой.

Примечание: Я использовал демо-версию VMProtect 3.5 для своих тестов.

## Введение
Прежде всего, знайте, что вам нужно "пометить" все функции, которые вы хотите мутировать, в коде (вызов `VMProtectBeginMutation`), или из программы VMP (пометка вручную по адресам или с использованием PDB файлов). Таким образом, чтобы быстро связать это с моим постом о виртуализации в **коммерческих продуктах**, если вы просто применяете защиту без пометки каких-либо функций (как это делают некоторые программы), VMP бесполезен.

Чтобы узнать больше о мутации кода, я создал шаблонную функцию и мутировал её 20 раз.

![Image 1](/quick-look-around-vmp-3x-part-2/1.png)

Каждая мутированная функция в секции кода переходит к секции VMP, которая содержит следующий код для выполнения. Потому что модификация (вставка) оригинальной секции кода, созданной компилятором, невозможна без разрушения всей структуры кода. Таким образом, VMP хранит все мутированные функции в новой секции, чтобы избежать проблем с размером (см.: Insert Code in PE).

Мутация VMP - это комбинация множества трюков, мутации кода, мусорного кода, управления потоком и невыравнивания блоков.

## Мутация и мусорный код
Когда я начал изучать это, я был действительно удивлен, увидев, что VMP не сосредоточен на мутации оригинальных инструкций. Оригинальные инструкции мутируются только на 1/2 (на основе того, что я видел, это может быть неверно).

Однако, это не плохо, VMP известен своими исследованиями в области оптимизации. И если они делают реальную мутацию кода на 1/2, на это должна быть причина.

В любом случае, основное, что меняется при сравнении мутированных функций, - это вставка мусорного кода.

![Image 2](/quick-look-around-vmp-3x-part-2/2.png)

Вы можете увидеть мусорный код, выделенный красным, он вставляется после каждой оригинальной или мутированной инструкции. Количество мусорных инструкций варьируется от 0 до 3. Часто мусорные инструкции, следующие за оригинальной инструкцией, используют регистр, который будет перезаписан следующей оригинальной инструкцией.

Также, как вы можете видеть, инструкции, используемые для генерации мусорного кода, необычны, и их можно легко заметить. Например: `rcr`, `bt`, `btc`, `sbb`, `lahf`...

Вот инструкции, которые VMProtect использует чаще всего для мутации кода:
```json
[
  "cwd",
  "stc",
  "rcl",
  "cdq",
  "setb",
  "nop",
  "cmovge",
  "setae",
  "sete",
  "rdtsc",
  "cmovs",
  "sbb",
  "setl",
  "setno",
  "cmovo",
  "setbe",
  "cmovl",
  "cmovae",
  "btc",
  "cwde",
  "cdq",
  "cmovg",
  "seta",
  "cmovnp",
  "shld",
  "cmova",
  "cmovp",
  "shrd",
  "bsf",
  "clc",
  "cbw",
  "rcr",
  "btr",
  "stc",
  "adc",
  "cmc",
  "cmovle",
  "bt",
  "bts",
  "bsr",
  "setge"
]
```
Есть некоторые "чистые" вставки мусорного кода, такие как `mov`, `xchg`, `cmp` на одном и том же регистре, nops и операции на регистре, который будет сброшен сразу после реальной инструкцией. Что касается eflags, мы могли бы увидеть некоторые сбросы с использованием двойных вызовов `cmp` или `test`.

Что касается мутации оригинальных инструкций, мы можем наблюдать вещи вокруг инструкции lea, такие как mov eax, ebx в `lea eax, [ebx]`, `add eax, 3` в `lea eax, [eax + 3]` или `sub eax, 5` в `lea eax, [eax - 5]`. Также такие вещи, как `xor eax, eax`, переведенные в `sub eax, eax` или `mov eax, 0`. И это все, и этого достаточно, учитывая его **реалистичную** вставку мусора.

## Управление потоком

Как я сказал, VMP использует защиту управления потоком. Она сосредоточена на переходах между всеми базовыми блоками, а не на условных переходах, поэтому оригинальный поток управления может быть виден даже после мутации.

![Image 3](/quick-look-around-vmp-3x-part-2/3.png)
![Image 4](/quick-look-around-vmp-3x-part-2/4.png)

## Позиционирование блоков

Что касается управления потоком, каждый базовый блок (блок кода) размещается определенным образом с целью обмануть реверсера.

### Разделение функций

Давайте проиллюстрируем это на примере секции кода, здесь в темно-сером цвете:

![Image 5](/quick-look-around-vmp-3x-part-2/5.png)

Как вы можете видеть на первой части, инструкции объединены в один блок как функции.

Часть в светло-сером цвете - это заполнение (нулевые байты или инструкции `0xCC int3`) между функциями в секции кода. Это заполнение создается компилятором для соблюдения **Выравнивания функций** (см.: Insert Code in PE).

### Невыравнивание блоков

В дополнение к разделению функций, VMP использует заполнение случайного размера между кодами. Например, вот выравнивание, которое может быть создано компилятором.

![Image 6](/quick-look-around-vmp-3x-part-2/6.png)

Как вы можете видеть, первый в зеленом цвете следует за байтами `0xCC`, это однобайтовая инструкция, которая создает отладочное событие при выполнении. В этом случае это не должно происходить, но эта однобайтовая инструкция сохраняет "выравнивание" каждого следующего выполняемого кода (см. начало этого поста, если у вас есть проблемы с пониманием)

Далее давайте посмотрим на выравнивание мутированного кода VMP:

![Image 7](/quick-look-around-vmp-3x-part-2/7.png)

Здесь первый код в зеленом цвете выполняется, но в какой-то момент он перейдет к какому-то месту в коде (вторая часть в зеленом цвете), но мы не знаем куда. Таким образом, код ниже `call sub_863AF7` никогда не будет выполнен, но дизассемблер не знает этого и дизассемблирует его в любом случае. И это заполнение мусором! случайные данные, чтобы обмануть дизассемблер. И как вы можете видеть с кодом в красном цвете, он полностью неверен.

Это правильный способ дизассемблировать его:

![Image 8](/quick-look-around-vmp-3x-part-2/8.png)

Но чтобы знать это, нам нужно запустить исполняемый файл и следовать потоку его выполнения, чтобы отметить все пройденные блоки.

## Конкретный пример

В конкретном примере, вот функция C++. Мы все еще замечаем, что мутация сосредоточена на управлении потоком, но код остается читаемым. Мутация использует регистры, которые будут сброшены следующей "реальной" инструкцией, поэтому программа не ломается.

![Image 9](/quick-look-around-vmp-3x-part-2/9.png)

## Как от этого избавиться?

Ну, если вы абсолютно хотите удалить это, сначала вы можете написать инструмент для удаления инструкций, которые работают с регистром и сбрасывают его сразу после. После этого вы можете удалить бесполезные инструкции, такие как movs и cmps на одной и той же цели и другие вещи, о которых я говорил ранее. Другая идея может заключаться в удалении необычных инструкций, но это может быть опасно, если реальная программа выполняет какие-то хитрые операции. Последний подход - это трассировка данных или динамический анализ потока данных, путем трассировки поведения регистров и их данных, мы можем определить, что является мусорным кодом. Используя символьную эмуляцию, вы можете удалить бесполезные инструкции с помощью фреймворков, таких как `miasm` или `triton` (см. пример здесь)

## Заключение

VMP впечатляет, и его механизм мутации может сделать процесс реверса или девиртуализации намного длиннее, чем должно быть, даже если мусорный код можно заметить. С высокопроизводительными оптимизациями, мусорные инструкции могут быть трудно отделимы от реального кода в некоторых случаях (C++ и другие виртуализированные вещи). В Ultra Mode (мутированный код виртуализирован), эта мутация должна быть проблемой, когда вам нужно девиртуализировать опкод.

Что касается сигнатуры кода, это идеально, если вы хотите сделать свой код другим без добавления бесполезного мусорного кода, это одно из лучших решений. Лично я использую это для обхода проверок сигнатур Anti-cheats, но вы могли бы использовать это для некоторых других целей x)

ОБНОВЛЕНИЕ: После того, как я некоторое время находился в виртуализированных рутинах VMP (которые мутированы), я думаю, что они должны использовать более традиционные инструкции и общие регистры. Потому что иначе вы можете легко заметить мусорный код, у них есть возможность знать, какой размер регистра используется в контексте кода, и они должны сохранять тот же "поток" размера манипуляции данными вместо того, чтобы переключаться с `eax` на `al` и возвращаться обратно к `ax`.