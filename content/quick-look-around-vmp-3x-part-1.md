---
name: Краткий обзор VMP 3.x — Часть 1. Распаковка
description: VMP — это хорошо известная защита с множеством функций...
date: 9.12.2025
---

Привет!

Это мое исследование безопасности VMProtect. VMP — это хорошо известная защита с множеством функций, основными из которых являются мутация кода и виртуализация, и по сравнению с ними эта часть является самой простой в VMP. Я расскажу обо всех этих функциях в будущих постах, но сейчас сосредоточусь на упаковке и обфускации импорта.

## Распаковка
Упаковка заключается в сжатии/шифровании секций исполняемого файла для предотвращения статического анализа. Это не очень эффективно, учитывая, что код и секции должны быть расшифрованы в какой-то момент во время выполнения.

![Unpacking Image](/quick-look-around-vmp-3x-part-1/1.png)

В данном случае VMProtect не хранит реальную информацию о разделах «RawFile» в заголовке PE, что является положительным моментом. Однако виртуальные адреса и размер должны храниться в заголовке, чтобы ядро могло выделить правильный размер для исполняемого файла, поэтому мы все же можем определить размеры разделов и возможные адреса (без учета ASLR).

Что касается упаковки в исходном файле, все содержимое объединено в одном из разделов VMP `.vmp1` (зашифрованные разделы, процедура распаковки, информация о разделах и т. д.).

Единственный раздел, который не «защищен», — это `.rsrc`, поскольку Windows необходимо его прочитать, чтобы извлечь значки и другую информацию для отображения в меню свойств. VMProtect имеет опцию защиты ресурсов в этом отношении, поэтому он может разделить ресурсы на две части, одну из которых Windows может прочитать. А другая содержит только «данные программы», зашифрованные и расшифрованные во время выполнения программы.

Как мы видим на скриншоте, за исключением секции .data, все секции не доступны для записи. Поэтому VMP должен вызвать `VirtualProtect` (или что-то подобное), чтобы изменить атрибуты секции и изменить их. Фактически, VMP использовал `VirtualProtect` в прошлом, но начиная с версии 3.x, он использует более высокий «недокументированный» API ядра под названием `ZwProtectVirtualMemory`, который имеет ту же цель.

Теперь мы можем приступить к динамической распаковке! Учитывая, что `ZwProtectVirtualMemory` вызывается много раз внутренними компонентами Windows, мы поставим на него точку останова только тогда, когда будет достигнута точка входа.

![Unpacking Image 2](/quick-look-around-vmp-3x-part-1/2.png)

Обратите внимание, что точка входа выглядит как виртуализированная процедура VMProtect, и на самом деле это так! В прошлом (версия 2.x) процедура распаковки VMP не была виртуализирована ([как в этом видео](https://www.youtube.com/watch?v=aoa89Khfgr0)), поэтому было легко поспешить и поставить точку останова на переход к OEP (`push` и `ret`).

![Unpacking Image 3](/quick-look-around-vmp-3x-part-1/3.png)

Итак, теперь мы знаем, что VMP должен изменить атрибуты раздела один раз для записи и один раз для восстановления атрибутов раздела. После небольших проб и ошибок, вот количество вызовов `ZwProtectVirtualMemory`, которое мы должны получить.

```
n = count of section that are not writable
n + 1 (.vmp0) : change protect to writable flag
1             : remove COPY flag
n + 1 (.vmp0) : restore original flags
```

Так что `((n + 1) * 2) + 1` чтобы получить распакованный PE, вот GIF этого в действии (смотрите флаги справа):

![Unpacking Image 4](/quick-look-around-vmp-3x-part-1/4.png)

И отсюда мы можем просто дампнуть исполняемый файл любым инструментом, чтобы получить чистый дамп (без исправленных импортов) PE.

Из этого (и из части 2 моего исследования VMP) я предположу, что раздел `.vmp0` содержит виртуализированный/мутированный код программиста (и код, связанный с IAT), а `.vmp1` содержит все, что связано с процессом распаковки (зашифрованные секции, виртуализированная процедура распаковки, информация о секциях и т.д.)

## Нахождение OEP
Поскольку процедура распаковки виртуализирована, найти её из кода VMP довольно сложно. Поэтому нам нужно использовать некоторые трюки. В этом случае я подумал, что это может сработать, если я буду отслеживать EIP и сохранять его, когда он переключается с .vmp1 на другой раздел, который не является .vmp0, и это сработало. Я попробовал скрипт Qiling для этого, но поскольку Qiling не реализует ZwProtectVirtualMemory, я не могу сделать многое. Поэтому я написал скрипт на Python с использованием unicorn, чтобы выполнить это.

Мы можем получить тот же результат, установив аппаратную точку останова на выполнение в секции .text. В моем случае OEP был первой функцией в начале .text, но это редкий случай, поэтому вы, вероятно, никогда не встретите такой.

Вы можете найти OEP, посмотрев на первый стековый куки функции (как в этой очень хорошей статье), который имеет значение 0x2B992DDFA232, когда исполняемый файл компилируется с помощью VC++.

Вы все еще можете найти OEP вручную, пытаясь дойти до низа стека, чтобы найти возможный первый адрес возврата.

## Оbfusaction IAT
Оbfusaction IAT в VMP является опциональной и не установлена по умолчанию. Поэтому реконструкция IAT не обязательна, когда разработчик не знает, как использовать VMP (и поверьте мне, это иногда случается). Конечно, я включил это для моего поста :)

Первое, что нужно увидеть, это то, что оригинальная IAT все еще сохранена, но не используется.

![Unpacking Image 5](/quick-look-around-vmp-3x-part-1/5.png)

Таким образом, вы можете увидеть, какие API использует программа, но вы не можете связать их с кодом (перекрестные ссылки), потому что адреса импорта "вычисляются" во время выполнения. На мой взгляд, они должны импортировать одну случайную функцию из DLL, если хотят сохранить IAT чистой, а не просто оставлять все на месте. Или просто полностью удалить содержимое IAT и загружать каждую DLL с помощью `LoadLibrary` и разрешать импорты позже.

Таким образом, если мы посмотрим на вызов API в исполняемом файле, мы можем заметить, что, к счастью, вызовы API только мутированы, а не виртуализированы!

Каждый вызов IAT в `.text`, пример: `call dword ptr ds:[<&CreateProcessW>]`, имеет длину 6 байт.

VMP изменил каждый вызов API на такой вызов:

```nasm
push random_register
call mutated_api_resolver
```

Эти две инструкции также занимают около 6 байт, чтобы сохранить "выравнивание" кода. Существует одна функция `mutated_api_resolver` для каждого вызова API, это может объяснить, почему VMP создает такие большие выходные данные (также из-за виртуализации). Таким образом, VMP использует регистр `random_register`, чтобы передать что-то в resolver API.

Вот мутированная версия (edi - это random_register):

> [!INFO]
> Этот код, как я сказал, находится в секции .vmp0
```nasm
nop
not di
bswap di
jmp ...
pop edi
jmp ...
xchg dword ptr ss:[esp], edi
push edi
not edi
xchg di, di
jmp ...
mov edi, 0x401113
mov edi, dword ptr ds:[edi + 0x2B21E]
jmp ...
lea edi, dword ptr ds:[edi + 0x724F2141]
jmp ...
xchg dword ptr ss:[esp], edi
jmp ...
ret
```
А вот очищенная версия (reg - это random_register):
```asm
# reg - это переданный регистр
# получаем адрес возврата из вызова
pop reg
# меняем местами переданный "reg" и адрес возврата из вызова
# так что возврат из вызова API вернется к вызывающему API
xchg dword ptr ss:[esp], reg
# устанавливаем будущий адрес возврата для перехода к функции API
push reg
# вычисляем адрес функции
# смещение к CreateProcessW в kernel32.dll в расчетах VMP
mov reg, 0x401113
# вычисляем адрес функции из смещения
# эти значения - статические смещения IAT и API
# получаем смещение IAT kernel32.dll в VMP
mov reg, dword ptr ds:[reg + 0x2B21E]
# получаем адрес CreateProcessW из смещения IAT kernel32.dll в VMP
lea reg, dword ptr ds:[reg + 0x724F2141]
# помещаем адрес функции API на вершину стека, используя "push reg" выше
xchg dword ptr ss:[esp], reg
# переходим к функции API
ret
```
Таким образом, чтобы подвести итог, VMP устанавливает переменную в стеке для перехода к следующему адресу API, выполняя `push` и `ret`.

Этот адрес вычисляется по формуле:
```nasm
reg = 0x401113        : смещение CreateProcessW + kernel32.dll
ds:[reg + 0x2B21E]    : адрес IAT kernel32.dll в VMP
ds:[reg + 0x724F2141] : адрес CreateProcessW
```

У меня нет достаточно времени, чтобы написать исправитель импорта, но это можно сделать во время выполнения с помощью эмуляции :) (unicorn, ..).

Некоторые инструменты были созданы 0xnobody, can1357 и mrxodia для распаковки и исправления импортов в x64 (здесь).